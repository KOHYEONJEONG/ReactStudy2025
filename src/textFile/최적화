# 최적화란(Optimization)?
웹 서비스의 성능을 개선하는 모든 행위를 일컫음
아주 단순한 것부터 아주 어려운 방법까지 다양하다.

# 일반적인 웹 서비스 최적화 방법
서버의 응답속도
정적파일 로딩속도 개선
불필요한 네트워크 요청 줄임
...

# 리액트 App 내부의 최적화 방법(리액트에서만 존재하는 특별한 최적화 방법)
컴포넌트 내부의 불 필요한 연산 방지
컴포넌트 내부의 불 필요한 함수 재생성 방지
컴포넌트의 불 필요한 리렌더링 방지

---------
# useMemo(메모제이션)
메모제이션(기억해두기,메모해두기) 기법을 기반으로
'볼 필요한 연산'을 최적화 하는 리액트 훅
자매품:useCallback(useMemo 기반으로 생성됨.)
ex(반복적으로 수행되는 동일한 연산 -> 최초에 생성한 값 메모리에 저장후  같은 연산이면 그대로 전달)
ㄴ 동일한 연산은 최초의 한번 연삽값을 저장해서 불필요한 연산을 하지 않는다.
ㄴ 생각보다 별거 아님
ㄴ 근사한 식사 중 엄청 독특한 음식일때 누군가 물어볼때 머릿속에 기억한 메뉴를 말해주는것처럼 기억해둔 메뉴명을 말해주고 있지 않은가?

🚩
객체를 반환하는 화살표 함수에서 return을 생략하려면 소괄호 ()로 감싸야 함.
useMemo(() => ( { ... } ), [의존성]) 방식은 암시적 반환(Implicit Return) 방식.
{} 중괄호를 사용하면 return이 반드시 필요함!

🚩
useMemo(() => {return 필수!} , [의존성])

# React.memo
- 내장함수
부모가 리렌더링되어도 
자신이 전달받은 props가 같으면(메모제이션되기때문에)
자식 컴포넌트는 불필요한 리렌더링하지 않는다.
사용 : memo(최적화할 컴포넌트명)

+ 주의(TodoItem.jsx 파일 참고)
객체와 함수는 값이 같아도, 메모리 주소가 다르면 다른 것으로 인식됨.
부모가 리렌더링되면, 내부에서 정의된 함수도 새로 생성되면서 새로운 함수로 인식됨.
그래서 React.memo를 사용할 때 onUpdate, onDelete 같은 함수는 비교하지 않음.
만약 함수가 변경되지 않도록 하려면 useCallback을 사용해야 함.