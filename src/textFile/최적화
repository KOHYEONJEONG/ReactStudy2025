# 최적화란(Optimization)?
웹 서비스의 성능을 개선하는 모든 행위를 일컫음
아주 단순한 것부터 아주 어려운 방법까지 다양하다.

# 일반적인 웹 서비스 최적화 방법
서버의 응답속도
정적파일 로딩속도 개선
불필요한 네트워크 요청 줄임
...

# 리액트 App 내부의 최적화 방법(리액트에서만 존재하는 특별한 최적화 방법)
컴포넌트 내부의 불 필요한 연산 방지
컴포넌트 내부의 불 필요한 함수 재생성 방지
컴포넌트의 불 필요한 리렌더링 방지

-------------------------
# useMemo(메모제이션)
메모제이션(기억해두기,메모해두기) 기법을 기반으로
'볼 필요한 연산'을 최적화 하는 리액트 훅
자매품:useCallback(useMemo 기반으로 생성됨.)
ex(반복적으로 수행되는 동일한 연산 -> 최초에 생성한 값 메모리에 저장후  같은 연산이면 그대로 전달)
ㄴ 동일한 연산은 최초의 한번 연삽값을 저장해서 불필요한 연산을 하지 않는다.
ㄴ 생각보다 별거 아님
ㄴ 근사한 식사 중 엄청 독특한 음식일때 누군가 물어볼때 머릿속에 기억한 메뉴를 말해주는것처럼 기억해둔 메뉴명을 말해주고 있지 않은가?

🚩
객체를 반환하는 화살표 함수에서 return을 생략하려면 소괄호 ()로 감싸야 함.
useMemo(() => ( { ... } ), [의존성]) 방식은 암시적 반환(Implicit Return) 방식.
{} 중괄호를 사용하면 return이 반드시 필요함!

🚩
useMemo(() => {return 필수!} , [의존성])

# React.memo
- 내장함수
부모가 리렌더링되어도 
자신이 전달받은 props가 같으면(메모제이션되기때문에)
자식 컴포넌트는 불필요한 리렌더링하지 않는다.
사용 : memo(최적화할 컴포넌트명, 콜백함수)

예시1) memo(Header)
예시2) memo(TotoItem, (prevProps, nextProps) => {...}); //왜? 얕은 비교를 하기 때문에 주소값으로 비교

+ 주의(TodoItem.jsx 파일 참고)
객체와 함수는 값이 같아도, 메모리 주소가 다르면 다른 것으로 인식됨.
부모가 리렌더링되면, 내부에서 정의된 함수도 새로 생성되면서 새로운 함수로 인식됨.
그래서 React.memo를 사용할 때 onUpdate, onDelete 같은 함수는 비교하지 않음.
만약 함수가 변경되지 않도록 하려면 useCallback을 사용해야 함.

-------------------------
# Redux
> 상태관리에 쓰이는 라이브러리 이다.
> 키워드들 중에 useReducer를 사용하면서 접해존 경험들이다.
(https://react.vlpt.us/redux/01-keywords.html)

...ETC

-------------------------
# 최적화 대상
연산, 함수, 컴포넌트
ex) Header라고 최적화할 필요 없음, 리렌더링이 더 빠를 수있다.

-------------------------
# 컨텍스트란?
기존의 props의 단점을 해결
부모 - > 자식 (O)
자식 -> 부모(리액트 구조상 안됐음)

용어 : 프롭스 드릴링(Props Drilling)
ㄴ 끝도 없이 타고 내려간다.
> 리액트 컨텍스트로 프롭스 드릴링을 해결한다.
> 컨텍스틀 통해 다이렉트로 props를 공급할 수 있다.


