원시타입과 객체 타입을 왜 나눌까?
- 원시타입과 객체 타입은 값이 저장되거나 복사되는 과정이 서로 다르기 때문

👀원시타입(불변값 : 바뀌지 않는 값.(상수랑 다른 개념, 💥메모리 값 수정 x))
- Number, String, Boolean 등...
ㄴ 값 자체로써 변수에 저장되고 복사
ㄴ 바뀌지 않는값? 
ex) let p2 = 1; 
p2 = 2; 
ㄴ 위에 1이 저장된 값이 2로 변경되는게 아닌 새로운 메모리에 새롭게 생성되면 즉즉
    '실제 메모리의 값을 수정되지 않는다.'

👀객체타입(가변값이다, 💥메모리 값 수정 O)
- Ojbect, Array, Function 등...
ㄴ 참조(주소)값을 통해 변수에 저장되고 복사된다.
ㄴ 보통 객체 타입은 '여러 개의 값을 저장함과 동시에 또 저장하는 값의 개수가 동적으로 막 유연하게 늘어났다가 줄어들기도 한다.'

let o1 = {name : "ko"}
let o2 = o1; //曰 : 얕은 복사(원복 객체도 수정될 위험성)
o2.name = "hyeon";

보통 객체타입은 '사이드 이펙트'를 줄 수 있다.
ㄴ 의도치 않게 값이 변해있음.

그래서 이름을 써줘서 이런 식으로 변수의 참조 값 자체를 복사하도록 하는 게 아니라 대신에 '새로운 객체를 생성'하고, 그 내부에 '...o1'처럼 스프레드 연사자 등을 이용해서 새로운 객체를 
생성하여 내부 프로퍼티만 '따로 복사해오는 요런 방식으로 객체를 복사함.'
let o3 = {...o1}; //曰 : 깊은 복사( 원본 객체를를 새로운 객체로 생성)

🚨객체간의 비교연산(曰 : 얕은 비교)
console.log(o1 === o2) //true(참조값으로 비교)
console.log(o1 === o3) //false(참조값으로 비교)


🚨값으로만 비교하려면 객체를 문자열로 변환하여 비교?(曰 : 깊은 비교)
'jsonStringify' 같은 '객체를 문자열로 형변환'하는 그런 '내장함수'를 이용해서
참조값이 아닌 프로퍼티를 기준으로 비교하도록 해야한다.

console.log(
    JSON.stringify(o1) === JSON.stringify(o3) 
)
//true


💥 💥배열과 함수도 사실 객체이다.💥 💥
객체(Ojbect) 
ㄴ함수 ㄴ 배열

배열과 함수도 특별한 객체이기 때문에
💥프로퍼티와 메서드를 다 가지고 있다.