리액트 컴포넌트와 라이프 사이클

https://react.vlpt.us/basic/16-useEffect.html

라이프 사이클 = 생애 주기(탄생부터 죽음까지)

✅ Mount- [탄생]
- 컴포넌트가 탄생하는 순간
- 렌더링 될 때를 의미
ㄴ A컴포넌트가 Mount되었다.
ㄴ A컴포넌트가 화면에 처음으로 렌더링 되었다.
ex)작업 : 서버에서 데이터를 요청을 보내 불러오는 작업
⏬
useEffect(() => {
  console.log('처음 한 번만 실행!');
}, []); // [] ← 빈 배열!


✅ Update(deps 파라미터 값 유/무)- [변화]
- 컴포넌트가 리렌더링되는 순간
- 리렌더링 될 때를 의미
ㄴ A컴포넌트가 업데이트 되었다.
ㄴ A컴포넌트가 리렌더링 되었다.
ex)작업 : 어떤 값이 변경되었는지 콘솔에 출력
->  🚨리액트 컴포넌트는 기본적으로 부모 컴포넌트가 리렌더링되면 자식 컴포넌트 또한 리렌더링 된다.(바뀐 내용이 없다고 해도)

🍒deps?
- 의존성 array

🚩deps에 특정 값을 넣게 된다면?
-> 컴포넌트가 처음 마운트 될 때에도 호출이 되고, 
-> 지정한 값이 바뀔 때에도 호출이 됩니다. 
그리고, 
-> 언마운트시에도 호출이되고, 
-> 값이 바뀌기 직전에도 호출이 됩니다.

🚩deps를 생략한다면?
-> 컴포넌트가 리렌더링될 때마다 호출된다.

⏬
useEffect(() => {
  console.log(`count가 ${count}로 바뀜`);
}, [count]); // count가 바뀔 때만 다시 실행됨


✅ UnMount- [죽음]
- 컴포넌트가 화면에서 사라지는 순간
- 렌더링에서 제외 되는 순간을 의미
ㄴ A컴포넌트가 UnMount되었다.
ㄴ A컴포넌트가 화면에서 사라졌다.
ex)작업 : 컴포넌트가 사용했던 메모리 정리


즉, 컴포넌트가 더 이상 필요 없어지고 DOM에서 사라질때  실행되는 시점.

1. 리소스 정리
- setInterval, setTimeout 정리
- EventListener 제거
- 외부 API나 소켓 연결 해제

2. 메모리 누수 방지
- 비동기 요청 중인데 컴포넌트가 사라지면 상태 업데이트하면 안됨.

3. 정리해야 할 사이드 이펙트가 있을 시
- 상태 저장, 클린업 등

⏬
1. 컴포넌트 선언 : {count % 2 === 0 ? <Even /> : null}
2. UnMount 사용 예시:

useEffect(() => {//📌useEffect(() => { ... })는 동기 함수

    return () => {
        console.log("Even : unmount");
    };
}, []);


# 💢주의
참고로 부모 컴포넌트가 리렌더링되면은 자식 컴포넌트 또한 리렌더링 된다.
물론 실제 dom에 변화가 있는것만 바뀌지만, virtual dom에는 모든걸 다 렌더링하고 있다.
- 그래서 최적화 작업을 통해, 기존에 내용을 그대로 사용하면서 virtual dom에 렌더링하는 리소스를 아낄 수 있다.
-- (17,18,19)
-- https://react.vlpt.us/basic/17-useMemo.html

#생명주기 직관적 정리
탄생 < 변화 < 죽음

#라이프 사이클 '제어'
useEffect로 손쉽게 가능. 

#같이보기
사이드이펙트.txt